# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ToolBox
                                 A QGIS plugin
 This plugin is a suite of tools for the ImPact Analysis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2020-07-27
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Hamed Eftekhar @ ANYWAYS
        email                : hamed@anyways.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, qVersion
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.core import *
from qgis.utils import iface
from qgis.gui import QgsMessageBar

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .ImPact_toolbox_dialog import ToolBoxDialog
import os.path
import requests
import pandas as pd
import shutil
import json
import time
import asyncio
import aiohttp
import backoff
import sys


class ToolBox:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ToolBox_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&ImPact toolbox')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ToolBox', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/ImPact_toolbox/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'ImPact ToolBox'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&ImPact toolbox'),
                action)
            self.iface.removeToolBarIcon(action)

    def input(self):
        xlfile, _filter = QFileDialog.getOpenFileName(self.dlg, "Select the Database", "", '*.xlsx')
        self.dlg.lineEdit_27.setText(xlfile)

    def input2(self):
        Tij, _filter = QFileDialog.getOpenFileName(self.dlg, "Select the Tij file", "", '(*.json *.geojson)')
        self.dlg.lineEdit_29.setText(Tij)

    def input3(self):
        Tij2, _filter = QFileDialog.getOpenFileName(self.dlg, "Select the Tij file", "", '(*.json *.geojson)')
        self.dlg.lineEdit_31.setText(Tij2)

    def output(self):
        foldername = QFileDialog.getExistingDirectory(self.dlg, "Select a directory to save routings", "")
        self.dlg.lineEdit_8.setText(foldername)

    def output2(self):
        foldername2 = QFileDialog.getExistingDirectory(self.dlg, "Select a directory to save routings", "")
        self.dlg.lineEdit_10.setText(foldername2)

    def output3(self):
        foldername3 = QFileDialog.getExistingDirectory(self.dlg, "Select a directory to save routings", "")
        self.dlg.lineEdit_4.setText(foldername3)

    def output4(self):
        foldername4 = QFileDialog.getExistingDirectory(self.dlg, "Select a directory to save routings", "")
        self.dlg.lineEdit_6.setText(foldername4)

    def output5(self):
        foldername5 = QFileDialog.getExistingDirectory(self.dlg, "Select a directory to save routings", "")
        self.dlg.lineEdit_24.setText(foldername5)

    def output6(self):
        foldername6 = QFileDialog.getExistingDirectory(self.dlg, "Select a directory to save routings", "")
        self.dlg.lineEdit_17.setText(foldername6)

    def output7(self):
        foldername7 = QFileDialog.getExistingDirectory(self.dlg, "Select a directory to save the Tij file", "")
        self.dlg.lineEdit_26.setText(foldername7)

    def output8(self):
        foldername8 = QFileDialog.getExistingDirectory(self.dlg, "Select a directory to save routings", "")
        self.dlg.lineEdit_15.setText(foldername8)

    def output9(self):
        foldername9 = QFileDialog.getExistingDirectory(self.dlg, "Select a directory to save routings", "")
        self.dlg.lineEdit_20.setText(foldername9)

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = ToolBoxDialog()

            self.dlg.pushButton_1.clicked.connect(self.output)
            self.dlg.pushButton_2.clicked.connect(self.output2)
            self.dlg.pushButton_3.clicked.connect(self.output3)
            self.dlg.pushButton_4.clicked.connect(self.output4)
            self.dlg.pushButton_5.clicked.connect(self.output5)
            self.dlg.pushButton_6.clicked.connect(self.output6)
            self.dlg.pushButton_7.clicked.connect(self.input)
            self.dlg.pushButton_8.clicked.connect(self.output8)
            self.dlg.pushButton_9.clicked.connect(self.output7)
            self.dlg.pushButton_10.clicked.connect(self.output9)
            self.dlg.pushButton_11.clicked.connect(self.input2)
            self.dlg.pushButton_12.clicked.connect(self.input3)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            if self.dlg.toolBox.currentIndex() == 0:
                if self.dlg.tabWidget_1.currentIndex() == 0:
                    if self.dlg.checkBox_3.isChecked():
                        ODLayer = self.dlg.mMapLayerComboBox_4.currentLayer()
                        if ODLayer.crs() == 4326:
                            features = ODLayer.getFeatures()
                        else:
                            crsSrc = QgsCoordinateReferenceSystem(ODLayer.crs())
                            crsDest = QgsCoordinateReferenceSystem(4326)
                            xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                            features = []
                            for f in ODLayer.getFeatures():
                                g = f.geometry()
                                g.transform(xform)
                                f.setGeometry(g)
                                features.append(f)

                        df = []
                        check = False
                        for feature in features:
                            if feature.geometry().isNull() == False:
                                Id = feature[0]
                                point = feature.geometry().asPoint()
                                X = point.x()
                                Y = point.y()
                                XY = str(X) + ',' + str(Y)
                                df.append([Id, XY])
                            else:
                                while check == False:
                                    self.iface.messageBar().pushMessage(u'ImPact_toolbox Warning',
                                                                        u'The POIs Layer has Null geometries!',
                                                                        level=Qgis.Warning, duration=0)
                                    check = True

                        poi = pd.DataFrame(df)
                        path = self.dlg.lineEdit_8.text()
                        PROFILE = self.dlg.RoutingProfiles_3.currentText().lower()

                        POIs = poi.rename(columns={poi.columns[0]: "Points", poi.columns[1]: "coordinates"})

                        # create new dataframe
                        OD = pd.DataFrame(columns=['Origins', 'FROM', 'Destinations', 'TO'])
                        # iterate through the POIs
                        new_index = 0
                        for o_POIs in POIs.index:
                            for d_POIs in POIs.index:
                                ls = [POIs.Points.loc[o_POIs], POIs.coordinates.loc[o_POIs],
                                      POIs.Points.loc[d_POIs], POIs.coordinates.loc[d_POIs]]
                                OD.loc[new_index] = ls
                                new_index += 1
                        # remove double POIs
                        OD = OD[OD.Origins != OD.Destinations]
                        # dropping duplicate row (rows with everything the same)
                        OD.drop_duplicates(keep="first", inplace=True)
                        # Resetting the index of the dataframe
                        OD = OD.reset_index(drop=True)

                        OD2 = OD[['FROM', 'TO']]
                        OD2.insert(loc=0, column='PROFILE', value=PROFILE)
                        OD2.dropna(inplace=True)
                        my_list = OD2.to_dict(orient='records')

                        fnameList = []
                        timestr = time.strftime("%Y%m%d_%H%M%S")
                        failedReqs = []
                        failedReqs2 = []
                        ApiReqList = []
                        api_dic = {}

                        for i in range(0, len(my_list)):
                            api = "https://routing.anyways.eu/api/route?loc=FROM&loc=TO&profile=PROFILE"
                            for key in my_list[i].keys():
                                api = api.replace(key, my_list[i][key])
                                if key == 'TO':
                                    ApiReqList.append(api)
                                    api_dic.update({api: i})

                                else:
                                    pass

                        @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                        async def get(url, session):
                            try:
                                async with session.get(url=url) as response:
                                    obj = await response.json()
                                    i = api_dic[url]
                                    if obj.get("features") != None:
                                        for n in range(len(obj['features'])):
                                            obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])
                                    else:
                                        obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                            'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                           'profile': PROFILE}}]
                                        obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                        obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                        obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                        OD.Origins[i], OD.Destinations[i])

                                    f = open(path + "/%s to %s by %s" % (
                                        OD.Origins[i], OD.Destinations[i], PROFILE.upper()) + ".json", "w+")
                                    f.write(json.dumps(obj))
                                    f.close()
                                    fnameList.append("%s to %s by %s" % (
                                        OD.Origins[i], OD.Destinations[i], PROFILE.upper()) + ".json")

                            except Exception as e:
                                failedReqs.append(url)

                        async def main(urls):
                            connector = aiohttp.TCPConnector()
                            session = aiohttp.ClientSession(connector=connector)

                            ret = await asyncio.gather(*[get(url, session) for url in urls])
                            await session.close()

                        urls = ApiReqList
                        asyncio.run(main(urls))

                        # 2nd round of reuqests (if there're failed requests in the 1st round)
                        if len(failedReqs) > 0:

                            @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                            async def get(url, session):
                                try:
                                    async with session.get(url=url) as response:
                                        obj = await response.json()
                                        i = api_dic[url]
                                        if obj.get("features") != None:
                                            for n in range(len(obj['features'])):
                                                obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                                obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                                obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                                OD.Origins[i], OD.Destinations[i])
                                        else:
                                            obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                                'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                               'profile': PROFILE}}]
                                            obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])

                                        f = open(path + "/%s to %s by %s" % (
                                            OD.Origins[i], OD.Destinations[i], PROFILE.upper()) + ".json", "w+")
                                        f.write(json.dumps(obj))
                                        f.close()
                                        fnameList.append("%s to %s by %s" % (
                                            OD.Origins[i], OD.Destinations[i], PROFILE.upper()) + ".json")

                                except Exception as e:
                                    failedReqs2.append(url)

                            async def main(urls):
                                connector = aiohttp.TCPConnector()
                                session = aiohttp.ClientSession(connector=connector)

                                ret = await asyncio.gather(*[get(url, session) for url in urls])
                                await session.close()

                            urls = failedReqs
                            asyncio.run(main(urls))

                        else:
                            pass

                        QgsMessageLog.logMessage('\n'.join(map(str, failedReqs2)), 'ImPact Toolbox', level=Qgis.Info)

                        GroupName = PROFILE.upper() + " Routings"
                        root = QgsProject.instance().layerTreeRoot()
                        shapeGroup = root.addGroup(
                            GroupName)  # Ater or Before (basically any name can be given to the group

                        os.chdir(path)
                        wholelist = os.listdir(os.getcwd())

                        for file in wholelist:
                            if file in fnameList:
                                fileroute = path + '/' + file
                                filename = QgsVectorLayer(fileroute, file[:-5], "ogr")
                                QgsProject.instance().addMapLayer(filename, False)
                                symbols = filename.renderer().symbols(QgsRenderContext())
                                sym = symbols[0]
                                c = self.dlg.mColorButton_3.color()
                                sym.setColor(QColor(c))
                                sym.setWidth(float(self.dlg.lineEdit_9.text()))
                                filename.triggerRepaint()
                                shapeGroup.insertChildNode(1, QgsLayerTreeLayer(filename))

                    else:
                        ODLayer = self.dlg.mMapLayerComboBox_4.currentLayer()
                        if ODLayer.crs() == 4326:
                            features = ODLayer.getFeatures()
                        else:
                            crsSrc = QgsCoordinateReferenceSystem(ODLayer.crs())
                            crsDest = QgsCoordinateReferenceSystem(4326)
                            xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                            features = []
                            for f in ODLayer.getFeatures():
                                g = f.geometry()
                                g.transform(xform)
                                f.setGeometry(g)
                                features.append(f)

                        df = []
                        check = False
                        for feature in features:
                            if feature.geometry().isNull() == False:
                                Id = feature[0]
                                point = feature.geometry().asPoint()
                                X = point.x()
                                Y = point.y()
                                XY = str(X) + ',' + str(Y)
                                df.append([Id, XY])
                            else:
                                while check == False:
                                    self.iface.messageBar().pushMessage(u'ImPact_toolbox Warning',
                                                                        u'The POIs Layer has Null geometries!',
                                                                        level=Qgis.Warning, duration=0)
                                    check = True

                        poi = pd.DataFrame(df)
                        path = self.dlg.lineEdit_8.text()
                        PROFILE = self.dlg.RoutingProfiles_3.currentText().lower()

                        POIs = poi.rename(columns={poi.columns[0]: "Points", poi.columns[1]: "coordinates"})

                        # create new dataframe
                        OD = pd.DataFrame(columns=['Origins', 'FROM', 'Destinations', 'TO'])
                        # iterate through the POIs
                        new_index = 0
                        for o_POIs in POIs.index:
                            for d_POIs in POIs.index:
                                ls = [POIs.Points.loc[o_POIs], POIs.coordinates.loc[o_POIs],
                                      POIs.Points.loc[d_POIs], POIs.coordinates.loc[d_POIs]]
                                OD.loc[new_index] = ls
                                new_index += 1
                        # remove double POIs
                        OD = OD[OD.Origins != OD.Destinations]
                        # dropping duplicate row (rows with everything the same)
                        OD.drop_duplicates(keep="first", inplace=True)
                        # Resetting the index of the dataframe
                        OD = OD.reset_index(drop=True)

                        OD2 = OD[['FROM', 'TO']]
                        OD2.insert(loc=0, column='PROFILE', value=PROFILE)
                        OD2.dropna(inplace=True)
                        my_list = OD2.to_dict(orient='records')

                        JsonMerged = {'type': 'FeatureCollection'}
                        featuresList = []
                        fnameList = []
                        timestr = time.strftime("%Y%m%d_%H%M%S")
                        failedReqs = []
                        failedReqs2 = []
                        ApiReqList = []
                        api_dic = {}

                        for i in range(0, len(my_list)):
                            api = "https://routing.anyways.eu/api/route?loc=FROM&loc=TO&profile=PROFILE"
                            for key in my_list[i].keys():
                                api = api.replace(key, my_list[i][key])
                                if key == 'TO':
                                    ApiReqList.append(api)
                                    api_dic.update({api: i})

                                else:
                                    pass

                        @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                        async def get(url, session):
                            try:
                                async with session.get(url=url) as response:
                                    obj = await response.json()
                                    i = api_dic[url]
                                    if obj.get("features") != None:
                                        for n in range(len(obj['features'])):
                                            obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])
                                    else:
                                        obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                            'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                           'profile': PROFILE}}]
                                        obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                        obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                        obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                        OD.Origins[i], OD.Destinations[i])

                                    for feats in obj['features']:
                                        featuresList.append(feats)

                            except Exception as e:
                                failedReqs.append(url)

                        async def main(urls):
                            connector = aiohttp.TCPConnector()
                            session = aiohttp.ClientSession(connector=connector)

                            ret = await asyncio.gather(*[get(url, session) for url in urls])
                            await session.close()

                        urls = ApiReqList
                        asyncio.run(main(urls))

                        # 2nd round of reuqests (if there're failed requests in the 1st round)
                        if len(failedReqs) > 0:

                            @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                            async def get(url, session):
                                try:
                                    async with session.get(url=url) as response:
                                        obj = await response.json()
                                        i = api_dic[url]
                                        if obj.get("features") != None:
                                            for n in range(len(obj['features'])):
                                                obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                                obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                                obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                                OD.Origins[i], OD.Destinations[i])
                                        else:
                                            obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                                'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                               'profile': PROFILE}}]
                                            obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])

                                        for feats in obj['features']:
                                            featuresList.append(feats)

                                except Exception as e:
                                    failedReqs2.append(url)

                            async def main(urls):
                                connector = aiohttp.TCPConnector()
                                session = aiohttp.ClientSession(connector=connector)

                                ret = await asyncio.gather(*[get(url, session) for url in urls])
                                await session.close()

                            urls = failedReqs
                            asyncio.run(main(urls))

                        else:
                            pass

                        QgsMessageLog.logMessage('\n'.join(map(str, failedReqs2)), 'ImPact Toolbox', level=Qgis.Info)

                        JsonMerged['features'] = featuresList

                        f = open(path + "/Routings_%s_" % (PROFILE.upper()) + timestr + ".json", "w+")
                        f.write(json.dumps(JsonMerged))
                        f.close()

                        Fname = "Routings_%s_" % (PROFILE.upper()) + timestr
                        fileroute = path + "/" + Fname + ".json"
                        filename = QgsVectorLayer(fileroute, Fname, "ogr")
                        QgsProject.instance().addMapLayer(filename, True)

                        lyr = iface.activeLayer()
                        symbols = lyr.renderer().symbols(QgsRenderContext())
                        sym = symbols[0]
                        c = self.dlg.mColorButton_3.color()
                        sym.setColor(QColor(c))
                        sym.setWidth(float(self.dlg.lineEdit_9.text()))
                        lyr.triggerRepaint()

                elif self.dlg.tabWidget_1.currentIndex() == 1:
                    if self.dlg.checkBox_4.isChecked():
                        OLayer = self.dlg.mMapLayerComboBox_5.currentLayer()
                        if OLayer.crs() == 4326:
                            features = OLayer.getFeatures()
                        else:
                            crsSrc = QgsCoordinateReferenceSystem(OLayer.crs())
                            crsDest = QgsCoordinateReferenceSystem(4326)
                            xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                            features = []
                            for f in OLayer.getFeatures():
                                g = f.geometry()
                                g.transform(xform)
                                f.setGeometry(g)
                                features.append(f)

                        dfO = []
                        check = False
                        for feature in features:
                            if feature.geometry().isNull() == False:
                                Id = feature[0]
                                point = feature.geometry().asPoint()
                                X = point.x()
                                Y = point.y()
                                XY = str(X) + ',' + str(Y)
                                dfO.append([Id, XY])
                            else:
                                while check == False:
                                    self.iface.messageBar().pushMessage(u'ImPact_toolbox Warning',
                                                                        u'The Origins Layer has Null geometries!',
                                                                        level=Qgis.Warning, duration=0)
                                    check = True

                        O1 = pd.DataFrame(dfO)

                        DLayer = self.dlg.mMapLayerComboBox_6.currentLayer()
                        if DLayer.crs() == 4326:
                            features = DLayer.getFeatures()
                        else:
                            crsSrc = QgsCoordinateReferenceSystem(DLayer.crs())
                            crsDest = QgsCoordinateReferenceSystem(4326)
                            xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                            features = []
                            for f in DLayer.getFeatures():
                                g = f.geometry()
                                g.transform(xform)
                                f.setGeometry(g)
                                features.append(f)

                        dfD = []
                        check = False
                        for feature in features:
                            if feature.geometry().isNull() == False:
                                Id = feature[0]
                                point = feature.geometry().asPoint()
                                X = point.x()
                                Y = point.y()
                                XY = str(X) + ',' + str(Y)
                                dfD.append([Id, XY])
                            else:
                                while check == False:
                                    self.iface.messageBar().pushMessage(u'ImPact_toolbox Warning',
                                                                        u'The Destinations Layer has Null geometries!',
                                                                        level=Qgis.Warning, duration=0)
                                    check = True

                        D1 = pd.DataFrame(dfD)

                        path = self.dlg.lineEdit_10.text()
                        PROFILE = self.dlg.RoutingProfiles_4.currentText().lower()

                        Origins = O1.rename(columns={O1.columns[0]: "O_Points", O1.columns[1]: "O_coordinates"})
                        Destinations = D1.rename(columns={O1.columns[0]: "D_Points", O1.columns[1]: "D_coordinates"})

                        # create new dataframe
                        OD = pd.DataFrame(columns=['Origins', 'FROM', 'Destinations', 'TO'])

                        new_index = 0
                        for origins in Origins.index:
                            for destinations in Destinations.index:
                                ls = [Origins.O_Points.loc[origins], Origins.O_coordinates.loc[origins],
                                      Destinations.D_Points.loc[destinations],
                                      Destinations.D_coordinates.loc[destinations]]
                                OD.loc[new_index] = ls
                                new_index += 1
                        # remove double POIs
                        OD = OD[OD.Origins != OD.Destinations]
                        # dropping duplicate row (rows with everything the same)
                        OD.drop_duplicates(keep="first", inplace=True)
                        # Resetting the index of the dataframe
                        OD = OD.reset_index(drop=True)

                        OD2 = OD[['FROM', 'TO']]
                        OD2.insert(loc=0, column='PROFILE', value=PROFILE)
                        OD2.dropna(inplace=True)
                        my_list = OD2.to_dict(orient='records')

                        fnameList = []
                        timestr = time.strftime("%Y%m%d_%H%M%S")
                        failedReqs = []
                        failedReqs2 = []
                        ApiReqList = []
                        api_dic = {}

                        for i in range(0, len(my_list)):
                            api = "https://routing.anyways.eu/api/route?loc=FROM&loc=TO&profile=PROFILE"
                            for key in my_list[i].keys():
                                api = api.replace(key, my_list[i][key])
                                if key == 'TO':
                                    ApiReqList.append(api)
                                    api_dic.update({api: i})

                                else:
                                    pass

                        @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                        async def get(url, session):
                            try:
                                async with session.get(url=url) as response:
                                    obj = await response.json()
                                    i = api_dic[url]
                                    if obj.get("features") != None:
                                        for n in range(len(obj['features'])):
                                            obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])
                                    else:
                                        obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                            'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                           'profile': PROFILE}}]
                                        obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                        obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                        obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                        OD.Origins[i], OD.Destinations[i])

                                    f = open(path + "/%s to %s by %s" % (
                                        OD.Origins[i], OD.Destinations[i], PROFILE.upper()) + ".json", "w+")
                                    f.write(json.dumps(obj))
                                    f.close()
                                    fnameList.append("%s to %s by %s" % (
                                        OD.Origins[i], OD.Destinations[i], PROFILE.upper()) + ".json")

                            except Exception as e:
                                failedReqs.append(url)

                        async def main(urls):
                            connector = aiohttp.TCPConnector()
                            session = aiohttp.ClientSession(connector=connector)

                            ret = await asyncio.gather(*[get(url, session) for url in urls])
                            await session.close()

                        urls = ApiReqList
                        asyncio.run(main(urls))

                        # 2nd round of reuqests (if there're failed requests in the 1st round)
                        if len(failedReqs) > 0:

                            @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                            async def get(url, session):
                                try:
                                    async with session.get(url=url) as response:
                                        obj = await response.json()
                                        i = api_dic[url]
                                        if obj.get("features") != None:
                                            for n in range(len(obj['features'])):
                                                obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                                obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                                obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                                OD.Origins[i], OD.Destinations[i])
                                        else:
                                            obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                                'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                               'profile': PROFILE}}]
                                            obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])

                                        f = open(path + "/%s to %s by %s" % (
                                            OD.Origins[i], OD.Destinations[i], PROFILE.upper()) + ".json", "w+")
                                        f.write(json.dumps(obj))
                                        f.close()
                                        fnameList.append("%s to %s by %s" % (
                                            OD.Origins[i], OD.Destinations[i], PROFILE.upper()) + ".json")

                                except Exception as e:
                                    failedReqs2.append(url)

                            async def main(urls):
                                connector = aiohttp.TCPConnector()
                                session = aiohttp.ClientSession(connector=connector)

                                ret = await asyncio.gather(*[get(url, session) for url in urls])
                                await session.close()

                            urls = failedReqs
                            asyncio.run(main(urls))

                        else:
                            pass

                        QgsMessageLog.logMessage('\n'.join(map(str, failedReqs2)), 'ImPact Toolbox', level=Qgis.Info)

                        GroupName = PROFILE.upper() + " Routings"
                        root = QgsProject.instance().layerTreeRoot()
                        shapeGroup = root.addGroup(
                            GroupName)  # Ater or Before (basically any name can be given to the group

                        os.chdir(path)
                        wholelist = os.listdir(os.getcwd())

                        for file in wholelist:
                            if file in fnameList:
                                fileroute = path + '/' + file
                                filename = QgsVectorLayer(fileroute, file[:-5], "ogr")
                                QgsProject.instance().addMapLayer(filename, False)
                                symbols = filename.renderer().symbols(QgsRenderContext())
                                sym = symbols[0]
                                c = self.dlg.mColorButton_4.color()
                                sym.setColor(QColor(c))
                                sym.setWidth(float(self.dlg.lineEdit_11.text()))
                                filename.triggerRepaint()
                                shapeGroup.insertChildNode(1, QgsLayerTreeLayer(filename))

                    else:
                        OLayer = self.dlg.mMapLayerComboBox_5.currentLayer()
                        if OLayer.crs() == 4326:
                            features = OLayer.getFeatures()
                        else:
                            crsSrc = QgsCoordinateReferenceSystem(OLayer.crs())
                            crsDest = QgsCoordinateReferenceSystem(4326)
                            xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                            features = []
                            for f in OLayer.getFeatures():
                                g = f.geometry()
                                g.transform(xform)
                                f.setGeometry(g)
                                features.append(f)

                        dfO = []
                        check = False
                        for feature in features:
                            if feature.geometry().isNull() == False:
                                Id = feature[0]
                                point = feature.geometry().asPoint()
                                X = point.x()
                                Y = point.y()
                                XY = str(X) + ',' + str(Y)
                                dfO.append([Id, XY])
                            else:
                                while check == False:
                                    self.iface.messageBar().pushMessage(u'ImPact_toolbox Warning',
                                                                        u'The Origins Layer has Null geometries!',
                                                                        level=Qgis.Warning, duration=0)
                                    check = True

                        O1 = pd.DataFrame(dfO)

                        DLayer = self.dlg.mMapLayerComboBox_6.currentLayer()
                        if DLayer.crs() == 4326:
                            features = DLayer.getFeatures()
                        else:
                            crsSrc = QgsCoordinateReferenceSystem(DLayer.crs())
                            crsDest = QgsCoordinateReferenceSystem(4326)
                            xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                            features = []
                            for f in DLayer.getFeatures():
                                g = f.geometry()
                                g.transform(xform)
                                f.setGeometry(g)
                                features.append(f)

                        dfD = []
                        check = False
                        for feature in features:
                            if feature.geometry().isNull() == False:
                                Id = feature[0]
                                point = feature.geometry().asPoint()
                                X = point.x()
                                Y = point.y()
                                XY = str(X) + ',' + str(Y)
                                dfD.append([Id, XY])
                            else:
                                while check == False:
                                    self.iface.messageBar().pushMessage(u'ImPact_toolbox Warning',
                                                                        u'The Destinations Layer has Null geometries!',
                                                                        level=Qgis.Warning, duration=0)
                                    check = True

                        D1 = pd.DataFrame(dfD)

                        path = self.dlg.lineEdit_10.text()
                        PROFILE = self.dlg.RoutingProfiles_4.currentText().lower()

                        Origins = O1.rename(columns={O1.columns[0]: "O_Points", O1.columns[1]: "O_coordinates"})
                        Destinations = D1.rename(columns={O1.columns[0]: "D_Points", O1.columns[1]: "D_coordinates"})

                        # create new dataframe
                        OD = pd.DataFrame(columns=['Origins', 'FROM', 'Destinations', 'TO'])

                        new_index = 0
                        for origins in Origins.index:
                            for destinations in Destinations.index:
                                ls = [Origins.O_Points.loc[origins], Origins.O_coordinates.loc[origins],
                                      Destinations.D_Points.loc[destinations],
                                      Destinations.D_coordinates.loc[destinations]]
                                OD.loc[new_index] = ls
                                new_index += 1
                        # remove double POIs
                        OD = OD[OD.Origins != OD.Destinations]
                        # dropping duplicate row (rows with everything the same)
                        OD.drop_duplicates(keep="first", inplace=True)
                        # Resetting the index of the dataframe
                        OD = OD.reset_index(drop=True)

                        OD2 = OD[['FROM', 'TO']]
                        OD2.insert(loc=0, column='PROFILE', value=PROFILE)
                        OD2.dropna(inplace=True)
                        my_list = OD2.to_dict(orient='records')

                        JsonMerged = {'type': 'FeatureCollection'}
                        featuresList = []
                        fnameList = []
                        timestr = time.strftime("%Y%m%d_%H%M%S")
                        failedReqs = []
                        failedReqs2 = []
                        ApiReqList = []
                        api_dic = {}

                        for i in range(0, len(my_list)):
                            api = "https://routing.anyways.eu/api/route?loc=FROM&loc=TO&profile=PROFILE"
                            for key in my_list[i].keys():
                                api = api.replace(key, my_list[i][key])
                                if key == 'TO':
                                    ApiReqList.append(api)
                                    api_dic.update({api: i})

                                else:
                                    pass

                        @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                        async def get(url, session):
                            try:
                                async with session.get(url=url) as response:
                                    obj = await response.json()
                                    i = api_dic[url]
                                    if obj.get("features") != None:
                                        for n in range(len(obj['features'])):
                                            obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])
                                    else:
                                        obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                            'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                           'profile': PROFILE}}]
                                        obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                        obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                        obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                        OD.Origins[i], OD.Destinations[i])

                                    for feats in obj['features']:
                                        featuresList.append(feats)

                            except Exception as e:
                                failedReqs.append(url)

                        async def main(urls):
                            connector = aiohttp.TCPConnector()
                            session = aiohttp.ClientSession(connector=connector)

                            ret = await asyncio.gather(*[get(url, session) for url in urls])
                            await session.close()

                        urls = ApiReqList
                        asyncio.run(main(urls))

                        # 2nd round of reuqests (if there're failed requests in the 1st round)
                        if len(failedReqs) > 0:

                            @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                            async def get(url, session):
                                try:
                                    async with session.get(url=url) as response:
                                        obj = await response.json()
                                        i = api_dic[url]
                                        if obj.get("features") != None:
                                            for n in range(len(obj['features'])):
                                                obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                                obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                                obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                                OD.Origins[i], OD.Destinations[i])
                                        else:
                                            obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                                'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                               'profile': PROFILE}}]
                                            obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])

                                        for feats in obj['features']:
                                            featuresList.append(feats)

                                except Exception as e:
                                    failedReqs2.append(url)

                            async def main(urls):
                                connector = aiohttp.TCPConnector()
                                session = aiohttp.ClientSession(connector=connector)

                                ret = await asyncio.gather(*[get(url, session) for url in urls])
                                await session.close()

                            urls = failedReqs
                            asyncio.run(main(urls))

                        else:
                            pass

                        QgsMessageLog.logMessage('\n'.join(map(str, failedReqs2)), 'ImPact Toolbox', level=Qgis.Info)

                        JsonMerged['features'] = featuresList

                        f = open(path + "/Routings_%s_" % (PROFILE.upper()) + timestr + ".json", "w+")
                        f.write(json.dumps(JsonMerged))
                        f.close()

                        Fname = "Routings_%s_" % (PROFILE.upper()) + timestr
                        fileroute = path + "/" + Fname + ".json"
                        filename = QgsVectorLayer(fileroute, Fname, "ogr")
                        QgsProject.instance().addMapLayer(filename, True)

                        lyr = iface.activeLayer()
                        symbols = lyr.renderer().symbols(QgsRenderContext())
                        sym = symbols[0]
                        c = self.dlg.mColorButton_4.color()
                        sym.setColor(QColor(c))
                        sym.setWidth(float(self.dlg.lineEdit_11.text()))
                        lyr.triggerRepaint()

            elif self.dlg.toolBox.currentIndex() == 1:
                if self.dlg.tabWidget_2.currentIndex() == 0:
                    if self.dlg.checkBox.isChecked():
                        ODLayer = self.dlg.mMapLayerComboBox.currentLayer()
                        if ODLayer.crs() == 4326:
                            features = ODLayer.getFeatures()
                        else:
                            crsSrc = QgsCoordinateReferenceSystem(ODLayer.crs())
                            crsDest = QgsCoordinateReferenceSystem(4326)
                            xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                            features = []
                            for f in ODLayer.getFeatures():
                                g = f.geometry()
                                g.transform(xform)
                                f.setGeometry(g)
                                features.append(f)

                        df = []
                        check = False
                        for feature in features:
                            if feature.geometry().isNull() == False:
                                Id = feature[0]
                                point = feature.geometry().asPoint()
                                X = point.x()
                                Y = point.y()
                                YX = str(Y) + ',' + str(X)
                                df.append([Id, YX])
                            else:
                                while check == False:
                                    self.iface.messageBar().pushMessage(u'ImPact_toolbox Warning',
                                                                        u'The POIs Layer has Null geometries!',
                                                                        level=Qgis.Warning, duration=0)
                                    check = True

                        poi = pd.DataFrame(df)

                        path = self.dlg.lineEdit_4.text()
                        INSTANCE = str.strip(self.dlg.lineEdit_12.text())
                        PROFILE = self.dlg.RoutingProfiles.currentText().lower()

                        POIs = poi.rename(columns={poi.columns[0]: "Points", poi.columns[1]: "coordinates"})

                        # create new dataframe
                        OD = pd.DataFrame(columns=['Origins', 'FROM', 'Destinations', 'TO'])
                        # iterate through the POIs
                        new_index = 0
                        for o_POIs in POIs.index:
                            for d_POIs in POIs.index:
                                ls = [POIs.Points.loc[o_POIs], POIs.coordinates.loc[o_POIs],
                                      POIs.Points.loc[d_POIs], POIs.coordinates.loc[d_POIs]]
                                OD.loc[new_index] = ls
                                new_index += 1
                        # remove double POIs
                        OD = OD[OD.Origins != OD.Destinations]
                        # dropping duplicate row (rows with everything the same)
                        OD.drop_duplicates(keep="first", inplace=True)
                        # Resetting the index of the dataframe
                        OD = OD.reset_index(drop=True)

                        OD2 = OD[['FROM', 'TO']]
                        OD2.insert(loc=0, column='INSTANCE', value=INSTANCE)
                        OD2.insert(loc=1, column='PROFILE', value=PROFILE)
                        OD2.dropna(inplace=True)
                        my_list = OD2.to_dict(orient='records')

                        fnameList = []
                        timestr = time.strftime("%Y%m%d_%H%M%S")
                        failedReqs = []
                        failedReqs2 = []
                        ApiReqList = []
                        api_dic = {}

                        for i in range(0, len(my_list)):
                            api = "https://api.anyways.eu/publish/opa/INSTANCE/routing?profile=PROFILE&loc=FROM&loc=TO"
                            for key in my_list[i].keys():
                                api = api.replace(key, my_list[i][key])
                                if key == 'TO':
                                    ApiReqList.append(api)
                                    api_dic.update({api: i})

                                else:
                                    pass

                        @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                        async def get(url, session):
                            try:
                                async with session.get(url=url) as response:
                                    obj = await response.json()
                                    i = api_dic[url]
                                    if obj.get("features") != None:
                                        for n in range(len(obj['features'])):
                                            obj['features'][n]['properties']['Instance'] = INSTANCE
                                            obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])
                                    else:
                                        obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                            'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                           'profile': PROFILE}}]
                                        obj['features'][0]['properties']['Instance'] = INSTANCE
                                        obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                        obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                        obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                        OD.Origins[i], OD.Destinations[i])

                                    f = open(path + "/%s to %s by %s_%s %s.json" % (
                                        OD.Origins[i], OD.Destinations[i], PROFILE.upper(),
                                        INSTANCE.replace("/", "-")[:-2],
                                        INSTANCE[-1]), "w+")
                                    f.write(json.dumps(obj))
                                    f.close()
                                    fnameList.append("%s to %s by %s_%s %s.json" % (
                                        OD.Origins[i], OD.Destinations[i], PROFILE.upper(),
                                        INSTANCE.replace("/", "-")[:-2],
                                        INSTANCE[-1]))

                            except Exception as e:
                                failedReqs.append(url)

                        async def main(urls):
                            connector = aiohttp.TCPConnector()
                            session = aiohttp.ClientSession(connector=connector)

                            ret = await asyncio.gather(*[get(url, session) for url in urls])
                            await session.close()

                        urls = ApiReqList
                        asyncio.run(main(urls))

                        # 2nd round of reuqests (if there're failed requests in the 1st round)
                        if len(failedReqs) > 0:

                            @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                            async def get(url, session):
                                try:
                                    async with session.get(url=url) as response:
                                        obj = await response.json()
                                        i = api_dic[url]
                                        if obj.get("features") != None:
                                            for n in range(len(obj['features'])):
                                                obj['features'][n]['properties']['Instance'] = INSTANCE
                                                obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                                obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                                obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                                OD.Origins[i], OD.Destinations[i])
                                        else:
                                            obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                                'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                               'profile': PROFILE}}]
                                            obj['features'][0]['properties']['Instance'] = INSTANCE
                                            obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])

                                        f = open(path + "/%s to %s by %s_%s %s.json" % (
                                            OD.Origins[i], OD.Destinations[i], PROFILE.upper(),
                                            INSTANCE.replace("/", "-")[:-2],
                                            INSTANCE[-1]), "w+")
                                        f.write(json.dumps(obj))
                                        f.close()
                                        fnameList.append("%s to %s by %s_%s %s.json" % (
                                            OD.Origins[i], OD.Destinations[i], PROFILE.upper(),
                                            INSTANCE.replace("/", "-")[:-2],
                                            INSTANCE[-1]))

                                except Exception as e:
                                    failedReqs2.append(url)

                            async def main(urls):
                                connector = aiohttp.TCPConnector()
                                session = aiohttp.ClientSession(connector=connector)

                                ret = await asyncio.gather(*[get(url, session) for url in urls])
                                await session.close()

                            urls = failedReqs
                            asyncio.run(main(urls))

                        else:
                            pass

                        QgsMessageLog.logMessage('\n'.join(map(str, failedReqs2)), 'ImPact Toolbox', level=Qgis.Info)

                        GroupName = "ShortCut " + INSTANCE.replace("/", " ") + ":" + PROFILE.upper()
                        root = QgsProject.instance().layerTreeRoot()
                        shapeGroup = root.addGroup(
                            GroupName)  # Ater or Before (basically any name can be given to the group

                        os.chdir(path)
                        wholelist = os.listdir(os.getcwd())

                        for file in wholelist:
                            if file in fnameList:
                                fileroute = path + '/' + file
                                filename = QgsVectorLayer(fileroute, file[:-5], "ogr")
                                QgsProject.instance().addMapLayer(filename, False)
                                symbols = filename.renderer().symbols(QgsRenderContext())
                                sym = symbols[0]
                                c = self.dlg.mColorButton.color()
                                sym.setColor(QColor(c))
                                sym.setWidth(float(self.dlg.lineEdit_5.text()))
                                filename.triggerRepaint()
                                shapeGroup.insertChildNode(1, QgsLayerTreeLayer(filename))

                    else:
                        ODLayer = self.dlg.mMapLayerComboBox.currentLayer()
                        if ODLayer.crs() == 4326:
                            features = ODLayer.getFeatures()
                        else:
                            crsSrc = QgsCoordinateReferenceSystem(ODLayer.crs())
                            crsDest = QgsCoordinateReferenceSystem(4326)
                            xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                            features = []
                            for f in ODLayer.getFeatures():
                                g = f.geometry()
                                g.transform(xform)
                                f.setGeometry(g)
                                features.append(f)

                        df = []
                        check = False
                        for feature in features:
                            if feature.geometry().isNull() == False:
                                Id = feature[0]
                                point = feature.geometry().asPoint()
                                X = point.x()
                                Y = point.y()
                                YX = str(Y) + ',' + str(X)
                                df.append([Id, YX])
                            else:
                                while check == False:
                                    self.iface.messageBar().pushMessage(u'ImPact_toolbox Warning',
                                                                        u'The POIs Layer has Null geometries!',
                                                                        level=Qgis.Warning, duration=0)
                                    check = True

                        poi = pd.DataFrame(df)

                        path = self.dlg.lineEdit_4.text()
                        INSTANCE = str.strip(self.dlg.lineEdit_12.text())
                        PROFILE = self.dlg.RoutingProfiles.currentText().lower()

                        POIs = poi.rename(columns={poi.columns[0]: "Points", poi.columns[1]: "coordinates"})

                        # create new dataframe
                        OD = pd.DataFrame(columns=['Origins', 'FROM', 'Destinations', 'TO'])
                        # iterate through the POIs
                        new_index = 0
                        for o_POIs in POIs.index:
                            for d_POIs in POIs.index:
                                ls = [POIs.Points.loc[o_POIs], POIs.coordinates.loc[o_POIs],
                                      POIs.Points.loc[d_POIs], POIs.coordinates.loc[d_POIs]]
                                OD.loc[new_index] = ls
                                new_index += 1
                        # remove double POIs
                        OD = OD[OD.Origins != OD.Destinations]
                        # dropping duplicate row (rows with everything the same)
                        OD.drop_duplicates(keep="first", inplace=True)
                        # Resetting the index of the dataframe
                        OD = OD.reset_index(drop=True)

                        OD2 = OD[['FROM', 'TO']]
                        OD2.insert(loc=0, column='INSTANCE', value=INSTANCE)
                        OD2.insert(loc=1, column='PROFILE', value=PROFILE)
                        OD2.dropna(inplace=True)
                        my_list = OD2.to_dict(orient='records')

                        JsonMerged = {'type': 'FeatureCollection'}
                        featuresList = []
                        fnameList = []
                        timestr = time.strftime("%Y%m%d_%H%M%S")
                        failedReqs = []
                        failedReqs2 = []
                        ApiReqList = []
                        api_dic = {}

                        for i in range(0, len(my_list)):
                            api = "https://api.anyways.eu/publish/opa/INSTANCE/routing?profile=PROFILE&loc=FROM&loc=TO"
                            for key in my_list[i].keys():
                                api = api.replace(key, my_list[i][key])
                                if key == 'TO':
                                    ApiReqList.append(api)
                                    api_dic.update({api: i})

                                else:
                                    pass

                        @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                        async def get(url, session):
                            try:
                                async with session.get(url=url) as response:
                                    obj = await response.json()
                                    i = api_dic[url]
                                    if obj.get("features") != None:
                                        for n in range(len(obj['features'])):
                                            obj['features'][n]['properties']['Instance'] = INSTANCE
                                            obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])
                                    else:
                                        obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                            'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                           'profile': PROFILE}}]
                                        obj['features'][0]['properties']['Instance'] = INSTANCE
                                        obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                        obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                        obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                        OD.Origins[i], OD.Destinations[i])

                                    for feats in obj['features']:
                                        featuresList.append(feats)

                            except Exception as e:
                                failedReqs.append(url)

                        async def main(urls):
                            connector = aiohttp.TCPConnector()
                            session = aiohttp.ClientSession(connector=connector)

                            ret = await asyncio.gather(*[get(url, session) for url in urls])
                            await session.close()

                        urls = ApiReqList
                        asyncio.run(main(urls))

                        # 2nd round of reuqests (if there're failed requests in the 1st round)
                        if len(failedReqs) > 0:

                            @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                            async def get(url, session):
                                try:
                                    async with session.get(url=url) as response:
                                        obj = await response.json()
                                        i = api_dic[url]
                                        if obj.get("features") != None:
                                            for n in range(len(obj['features'])):
                                                obj['features'][n]['properties']['Instance'] = INSTANCE
                                                obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                                obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                                obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                                OD.Origins[i], OD.Destinations[i])
                                        else:
                                            obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                                'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                               'profile': PROFILE}}]
                                            obj['features'][0]['properties']['Instance'] = INSTANCE
                                            obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])

                                        for feats in obj['features']:
                                            featuresList.append(feats)

                                except Exception as e:
                                    failedReqs2.append(url)

                            async def main(urls):
                                connector = aiohttp.TCPConnector()
                                session = aiohttp.ClientSession(connector=connector)

                                ret = await asyncio.gather(*[get(url, session) for url in urls])
                                await session.close()

                            urls = failedReqs
                            asyncio.run(main(urls))

                        else:
                            pass

                        QgsMessageLog.logMessage('\n'.join(map(str, failedReqs2)), 'ImPact Toolbox', level=Qgis.Info)

                        JsonMerged['features'] = featuresList

                        f = open(path + "/ShortCutRoutings_%s_" % (PROFILE.upper()) + timestr + ".json", "w+")
                        f.write(json.dumps(JsonMerged))
                        f.close()

                        Fname = "ShortCutRoutings_%s_" % (PROFILE.upper()) + timestr
                        fileroute = path + "/" + Fname + ".json"
                        filename = QgsVectorLayer(fileroute, Fname, "ogr")
                        QgsProject.instance().addMapLayer(filename, True)

                        lyr = iface.activeLayer()
                        symbols = lyr.renderer().symbols(QgsRenderContext())
                        sym = symbols[0]
                        c = self.dlg.mColorButton.color()
                        sym.setColor(QColor(c))
                        sym.setWidth(float(self.dlg.lineEdit_5.text()))
                        lyr.triggerRepaint()

                elif self.dlg.tabWidget_2.currentIndex() == 1:
                    if self.dlg.checkBox_2.isChecked():
                        OLayer = self.dlg.mMapLayerComboBox_2.currentLayer()
                        if OLayer.crs() == 4326:
                            features = OLayer.getFeatures()
                        else:
                            crsSrc = QgsCoordinateReferenceSystem(OLayer.crs())
                            crsDest = QgsCoordinateReferenceSystem(4326)
                            xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                            features = []
                            for f in OLayer.getFeatures():
                                g = f.geometry()
                                g.transform(xform)
                                f.setGeometry(g)
                                features.append(f)

                        dfO = []
                        check = False
                        for feature in features:
                            if feature.geometry().isNull() == False:
                                Id = feature[0]
                                point = feature.geometry().asPoint()
                                X = point.x()
                                Y = point.y()
                                YX = str(Y) + ',' + str(X)
                                dfO.append([Id, YX])
                            else:
                                while check == False:
                                    self.iface.messageBar().pushMessage(u'ImPact_toolbox Warning',
                                                                        u'The Origins Layer has Null geometries!',
                                                                        level=Qgis.Warning, duration=0)
                                    check = True

                        O1 = pd.DataFrame(dfO)

                        DLayer = self.dlg.mMapLayerComboBox_3.currentLayer()
                        if DLayer.crs() == 4326:
                            features = DLayer.getFeatures()
                        else:
                            crsSrc = QgsCoordinateReferenceSystem(DLayer.crs())
                            crsDest = QgsCoordinateReferenceSystem(4326)
                            xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                            features = []
                            for f in DLayer.getFeatures():
                                g = f.geometry()
                                g.transform(xform)
                                f.setGeometry(g)
                                features.append(f)

                        dfD = []
                        check = False
                        for feature in features:
                            if feature.geometry().isNull() == False:
                                Id = feature[0]
                                point = feature.geometry().asPoint()
                                X = point.x()
                                Y = point.y()
                                YX = str(Y) + ',' + str(X)
                                dfD.append([Id, YX])
                            else:
                                while check == False:
                                    self.iface.messageBar().pushMessage(u'ImPact_toolbox Warning',
                                                                        u'The Destinations Layer has Null geometries!',
                                                                        level=Qgis.Warning, duration=0)
                                    check = True
                        D1 = pd.DataFrame(dfD)

                        path = self.dlg.lineEdit_6.text()
                        INSTANCE = str.strip(self.dlg.lineEdit_13.text())
                        PROFILE = self.dlg.RoutingProfiles_2.currentText().lower()

                        Origins = O1.rename(columns={O1.columns[0]: "O_Points", O1.columns[1]: "O_coordinates"})
                        Destinations = D1.rename(columns={O1.columns[0]: "D_Points", O1.columns[1]: "D_coordinates"})

                        # create new dataframe
                        OD = pd.DataFrame(columns=['Origins', 'FROM', 'Destinations', 'TO'])

                        new_index = 0
                        for origins in Origins.index:
                            for destinations in Destinations.index:
                                ls = [Origins.O_Points.loc[origins], Origins.O_coordinates.loc[origins],
                                      Destinations.D_Points.loc[destinations],
                                      Destinations.D_coordinates.loc[destinations]]
                                OD.loc[new_index] = ls
                                new_index += 1
                        # remove double POIs
                        OD = OD[OD.Origins != OD.Destinations]
                        # dropping duplicate row (rows with everything the same)
                        OD.drop_duplicates(keep="first", inplace=True)
                        # Resetting the index of the dataframe
                        OD = OD.reset_index(drop=True)

                        OD2 = OD[['FROM', 'TO']]
                        OD2.insert(loc=0, column='INSTANCE', value=INSTANCE)
                        OD2.insert(loc=1, column='PROFILE', value=PROFILE)
                        OD2.dropna(inplace=True)
                        my_list = OD2.to_dict(orient='records')

                        fnameList = []
                        timestr = time.strftime("%Y%m%d_%H%M%S")
                        failedReqs = []
                        failedReqs2 = []
                        ApiReqList = []
                        api_dic = {}

                        for i in range(0, len(my_list)):
                            api = "https://api.anyways.eu/publish/opa/INSTANCE/routing?profile=PROFILE&loc=FROM&loc=TO"
                            for key in my_list[i].keys():
                                api = api.replace(key, my_list[i][key])
                                if key == 'TO':
                                    ApiReqList.append(api)
                                    api_dic.update({api: i})

                                else:
                                    pass

                        @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                        async def get(url, session):
                            try:
                                async with session.get(url=url) as response:
                                    obj = await response.json()
                                    i = api_dic[url]
                                    if obj.get("features") != None:
                                        for n in range(len(obj['features'])):
                                            obj['features'][n]['properties']['Instance'] = INSTANCE
                                            obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])
                                    else:
                                        obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                            'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                           'profile': PROFILE}}]
                                        obj['features'][0]['properties']['Instance'] = INSTANCE
                                        obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                        obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                        obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                        OD.Origins[i], OD.Destinations[i])

                                    f = open(path + "/%s to %s by %s_%s %s.json" % (
                                        OD.Origins[i], OD.Destinations[i], PROFILE.upper(),
                                        INSTANCE.replace("/", "-")[:-2],
                                        INSTANCE[-1]), "w+")
                                    f.write(json.dumps(obj))
                                    f.close()
                                    fnameList.append("%s to %s by %s_%s %s.json" % (
                                        OD.Origins[i], OD.Destinations[i], PROFILE.upper(),
                                        INSTANCE.replace("/", "-")[:-2],
                                        INSTANCE[-1]))

                            except Exception as e:
                                failedReqs.append(url)

                        async def main(urls):
                            connector = aiohttp.TCPConnector()
                            session = aiohttp.ClientSession(connector=connector)

                            ret = await asyncio.gather(*[get(url, session) for url in urls])
                            await session.close()

                        urls = ApiReqList
                        asyncio.run(main(urls))

                        # 2nd round of reuqests (if there're failed requests in the 1st round)
                        if len(failedReqs) > 0:

                            @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                            async def get(url, session):
                                try:
                                    async with session.get(url=url) as response:
                                        obj = await response.json()
                                        i = api_dic[url]
                                        if obj.get("features") != None:
                                            for n in range(len(obj['features'])):
                                                obj['features'][n]['properties']['Instance'] = INSTANCE
                                                obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                                obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                                obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                                OD.Origins[i], OD.Destinations[i])
                                        else:
                                            obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                                'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                               'profile': PROFILE}}]
                                            obj['features'][0]['properties']['Instance'] = INSTANCE
                                            obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])

                                        f = open(path + "/%s to %s by %s_%s %s.json" % (
                                            OD.Origins[i], OD.Destinations[i], PROFILE.upper(),
                                            INSTANCE.replace("/", "-")[:-2],
                                            INSTANCE[-1]), "w+")
                                        f.write(json.dumps(obj))
                                        f.close()
                                        fnameList.append("%s to %s by %s_%s %s.json" % (
                                            OD.Origins[i], OD.Destinations[i], PROFILE.upper(),
                                            INSTANCE.replace("/", "-")[:-2],
                                            INSTANCE[-1]))

                                except Exception as e:
                                    failedReqs2.append(url)

                            async def main(urls):
                                connector = aiohttp.TCPConnector()
                                session = aiohttp.ClientSession(connector=connector)

                                ret = await asyncio.gather(*[get(url, session) for url in urls])
                                await session.close()

                            urls = failedReqs
                            asyncio.run(main(urls))

                        else:
                            pass

                        QgsMessageLog.logMessage('\n'.join(map(str, failedReqs2)), 'ImPact Toolbox', level=Qgis.Info)

                        GroupName = "ShortCut " + INSTANCE.replace("/", " ") + ":" + PROFILE.upper()
                        root = QgsProject.instance().layerTreeRoot()
                        shapeGroup = root.addGroup(
                            GroupName)  # Ater or Before (basically any name can be given to the group

                        os.chdir(path)
                        wholelist = os.listdir(os.getcwd())

                        for file in wholelist:
                            if file in fnameList:
                                fileroute = path + '/' + file
                                filename = QgsVectorLayer(fileroute, file[:-5], "ogr")
                                QgsProject.instance().addMapLayer(filename, False)
                                symbols = filename.renderer().symbols(QgsRenderContext())
                                sym = symbols[0]
                                c = self.dlg.mColorButton_2.color()
                                sym.setColor(QColor(c))
                                sym.setWidth(float(self.dlg.lineEdit_7.text()))
                                filename.triggerRepaint()
                                shapeGroup.insertChildNode(1, QgsLayerTreeLayer(filename))

                    else:
                        OLayer = self.dlg.mMapLayerComboBox_2.currentLayer()
                        if OLayer.crs() == 4326:
                            features = OLayer.getFeatures()
                        else:
                            crsSrc = QgsCoordinateReferenceSystem(OLayer.crs())
                            crsDest = QgsCoordinateReferenceSystem(4326)
                            xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                            features = []
                            for f in OLayer.getFeatures():
                                g = f.geometry()
                                g.transform(xform)
                                f.setGeometry(g)
                                features.append(f)

                        dfO = []
                        check = False
                        for feature in features:
                            if feature.geometry().isNull() == False:
                                Id = feature[0]
                                point = feature.geometry().asPoint()
                                X = point.x()
                                Y = point.y()
                                YX = str(Y) + ',' + str(X)
                                dfO.append([Id, YX])
                            else:
                                while check == False:
                                    self.iface.messageBar().pushMessage(u'ImPact_toolbox Warning',
                                                                        u'The Origins Layer has Null geometries!',
                                                                        level=Qgis.Warning, duration=0)
                                    check = True
                        O1 = pd.DataFrame(dfO)

                        DLayer = self.dlg.mMapLayerComboBox_3.currentLayer()
                        if DLayer.crs() == 4326:
                            features = DLayer.getFeatures()
                        else:
                            crsSrc = QgsCoordinateReferenceSystem(DLayer.crs())
                            crsDest = QgsCoordinateReferenceSystem(4326)
                            xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                            features = []
                            for f in DLayer.getFeatures():
                                g = f.geometry()
                                g.transform(xform)
                                f.setGeometry(g)
                                features.append(f)

                        dfD = []
                        check = False
                        for feature in features:
                            if feature.geometry().isNull() == False:
                                Id = feature[0]
                                point = feature.geometry().asPoint()
                                X = point.x()
                                Y = point.y()
                                YX = str(Y) + ',' + str(X)
                                dfD.append([Id, YX])
                            else:
                                while check == False:
                                    self.iface.messageBar().pushMessage(u'ImPact_toolbox Warning',
                                                                        u'The Destinations Layer has Null geometries!',
                                                                        level=Qgis.Warning, duration=0)
                                    check = True
                        D1 = pd.DataFrame(dfD)

                        path = self.dlg.lineEdit_6.text()
                        INSTANCE = str.strip(self.dlg.lineEdit_13.text())
                        PROFILE = self.dlg.RoutingProfiles_2.currentText().lower()

                        Origins = O1.rename(columns={O1.columns[0]: "O_Points", O1.columns[1]: "O_coordinates"})
                        Destinations = D1.rename(columns={O1.columns[0]: "D_Points", O1.columns[1]: "D_coordinates"})

                        # create new dataframe
                        OD = pd.DataFrame(columns=['Origins', 'FROM', 'Destinations', 'TO'])

                        new_index = 0
                        for origins in Origins.index:
                            for destinations in Destinations.index:
                                ls = [Origins.O_Points.loc[origins], Origins.O_coordinates.loc[origins],
                                      Destinations.D_Points.loc[destinations],
                                      Destinations.D_coordinates.loc[destinations]]
                                OD.loc[new_index] = ls
                                new_index += 1
                        # remove double POIs
                        OD = OD[OD.Origins != OD.Destinations]
                        # dropping duplicate row (rows with everything the same)
                        OD.drop_duplicates(keep="first", inplace=True)
                        # Resetting the index of the dataframe
                        OD = OD.reset_index(drop=True)

                        OD2 = OD[['FROM', 'TO']]
                        OD2.insert(loc=0, column='INSTANCE', value=INSTANCE)
                        OD2.insert(loc=1, column='PROFILE', value=PROFILE)
                        OD2.dropna(inplace=True)
                        my_list = OD2.to_dict(orient='records')

                        JsonMerged = {'type': 'FeatureCollection'}
                        featuresList = []
                        fnameList = []
                        timestr = time.strftime("%Y%m%d_%H%M%S")
                        failedReqs = []
                        failedReqs2 = []
                        ApiReqList = []
                        api_dic = {}

                        for i in range(0, len(my_list)):
                            api = "https://api.anyways.eu/publish/opa/INSTANCE/routing?profile=PROFILE&loc=FROM&loc=TO"
                            for key in my_list[i].keys():
                                api = api.replace(key, my_list[i][key])
                                if key == 'TO':
                                    ApiReqList.append(api)
                                    api_dic.update({api: i})

                                else:
                                    pass

                        @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                        async def get(url, session):
                            try:
                                async with session.get(url=url) as response:
                                    obj = await response.json()
                                    i = api_dic[url]
                                    if obj.get("features") != None:
                                        for n in range(len(obj['features'])):
                                            obj['features'][n]['properties']['Instance'] = INSTANCE
                                            obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])
                                    else:
                                        obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                            'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                           'profile': PROFILE}}]
                                        obj['features'][0]['properties']['Instance'] = INSTANCE
                                        obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                        obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                        obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                        OD.Origins[i], OD.Destinations[i])

                                    for feats in obj['features']:
                                        featuresList.append(feats)

                            except Exception as e:
                                failedReqs.append(url)

                        async def main(urls):
                            connector = aiohttp.TCPConnector()
                            session = aiohttp.ClientSession(connector=connector)

                            ret = await asyncio.gather(*[get(url, session) for url in urls])
                            await session.close()

                        urls = ApiReqList
                        asyncio.run(main(urls))

                        # 2nd round of reuqests (if there're failed requests in the 1st round)
                        if len(failedReqs) > 0:

                            @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_time=60, max_tries=3)
                            async def get(url, session):
                                try:
                                    async with session.get(url=url) as response:
                                        obj = await response.json()
                                        i = api_dic[url]
                                        if obj.get("features") != None:
                                            for n in range(len(obj['features'])):
                                                obj['features'][n]['properties']['Instance'] = INSTANCE
                                                obj['features'][n]['properties']['From'] = "%s" % (OD.Origins[i])
                                                obj['features'][n]['properties']['To'] = "%s" % (OD.Destinations[i])
                                                obj['features'][n]['properties']['O_D'] = "%s_%s" % (
                                                OD.Origins[i], OD.Destinations[i])
                                        else:
                                            obj['features'] = [{'type': 'Feature', 'name': 'ShapeMeta',
                                                                'properties': {'name': 'N/A', 'highway': 'N/A',
                                                                               'profile': PROFILE}}]
                                            obj['features'][0]['properties']['Instance'] = INSTANCE
                                            obj['features'][0]['properties']['From'] = "%s" % (OD.Origins[i])
                                            obj['features'][0]['properties']['To'] = "%s" % (OD.Destinations[i])
                                            obj['features'][0]['properties']['O_D'] = "%s_%s" % (
                                            OD.Origins[i], OD.Destinations[i])

                                        for feats in obj['features']:
                                            featuresList.append(feats)

                                except Exception as e:
                                    failedReqs2.append(url)

                            async def main(urls):
                                connector = aiohttp.TCPConnector()
                                session = aiohttp.ClientSession(connector=connector)

                                ret = await asyncio.gather(*[get(url, session) for url in urls])
                                await session.close()

                            urls = failedReqs
                            asyncio.run(main(urls))

                        else:
                            pass

                        QgsMessageLog.logMessage('\n'.join(map(str, failedReqs2)), 'ImPact Toolbox', level=Qgis.Info)

                        JsonMerged['features'] = featuresList

                        f = open(path + "/ShortCutRoutings_%s_" % (PROFILE.upper()) + timestr + ".json", "w+")
                        f.write(json.dumps(JsonMerged))
                        f.close()

                        Fname = "ShortCutRoutings_%s_" % (PROFILE.upper()) + timestr
                        fileroute = path + "/" + Fname + ".json"
                        filename = QgsVectorLayer(fileroute, Fname, "ogr")
                        QgsProject.instance().addMapLayer(filename, True)

                        lyr = iface.activeLayer()
                        symbols = lyr.renderer().symbols(QgsRenderContext())
                        sym = symbols[0]
                        c = self.dlg.mColorButton_2.color()
                        sym.setColor(QColor(c))
                        sym.setWidth(float(self.dlg.lineEdit_7.text()))
                        lyr.triggerRepaint()

            elif self.dlg.toolBox.currentIndex() == 2:
                if self.dlg.tabWidget_3.currentIndex() == 0:
                    From_layer = self.dlg.mMapLayerComboBox_13.currentLayer()
                    if From_layer.crs() == 4326:
                        features = From_layer.getFeatures()
                    else:
                        crsSrc = QgsCoordinateReferenceSystem(From_layer.crs())
                        crsDest = QgsCoordinateReferenceSystem(4326)
                        xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                        features = []
                        for f in From_layer.getFeatures():
                            g = f.geometry()
                            g.transform(xform)
                            f.setGeometry(g)
                            features.append(f)

                    for feature in features:
                        vertices = feature.geometry().asMultiPolygon()

                    for v in vertices:
                        p = str(v)
                        l = [p.split(')')[0] for p in p.split('(') if ')' in p]

                    ll2 = []
                    for i in range(0, len(l)):
                        ll2.append([float(x) for x in l[i].split()])

                    To_layer = self.dlg.mMapLayerComboBox_12.currentLayer()
                    if To_layer.crs() == 4326:
                        features = To_layer.getFeatures()
                    else:
                        crsSrc = QgsCoordinateReferenceSystem(To_layer.crs())
                        crsDest = QgsCoordinateReferenceSystem(4326)
                        xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                        features = []
                        for f in To_layer.getFeatures():
                            g = f.geometry()
                            g.transform(xform)
                            f.setGeometry(g)
                            features.append(f)

                    for feature in features:
                        vertices = feature.geometry().asMultiPolygon()

                    for v in vertices:
                        p = str(v)
                        l = [p.split(')')[0] for p in p.split('(') if ')' in p]

                    ll = []
                    for i in range(0, len(l)):
                        ll.append([float(x) for x in l[i].split()])

                    DataSource = self.dlg.DataSource_1.currentText()

                    if DataSource.lower() == 'fod':
                        x = {"fromArea": {
                            "type": "FeatureCollection",
                            "features": [
                                {
                                    "type": "Feature",
                                    "properties": {},
                                    "geometry": {
                                        "type": "Polygon",
                                        "coordinates": [
                                            [
                                                0
                                            ]
                                        ]
                                    }
                                }
                            ]
                        },
                            "toArea": {
                                "type": "FeatureCollection",
                                "features": [
                                    {
                                        "type": "Feature",
                                        "properties": {},
                                        "geometry": {
                                            "type": "Polygon",
                                            "coordinates": [
                                                [
                                                    0
                                                ]
                                            ]
                                        }
                                    }
                                ]
                            }
                        }

                        x['fromArea']['features'][0]['geometry']['coordinates'][0] = ll2
                        x['toArea']['features'][0]['geometry']['coordinates'][0] = ll

                        data = json.dumps(x)

                        head = {'Content-type': 'application/json-patch+json', 'Accept': 'application/geo+json'}
                        response = requests.post('https://staging.anyways.eu/api/data/od/movement/area', data=data,
                                                 headers=head)

                        d = response.json()
                        if len(d['features']) == 0:
                            return self.iface.messageBar().pushMessage(u'ImPact_toolbox Error',
                                                                       u"There seem to be no Companies in the selected To-Area. Please verify at: <a href='https://staging.anyways.eu/mobility-data-explorer'>https://staging.anyways.eu/mobility-data-explorer</a>",
                                                                       level=Qgis.Critical, duration=0)
                            # QgsMessageLog.logMessage("There seem to be no Companies in the selected To-Area. Please verify at: https://staging.anyways.eu/mobility-data-explorer", 'ImPact Toolbox', level=Qgis.Info)

                        path = self.dlg.lineEdit_24.text()
                        JsonMerged = {'type': 'FeatureCollection'}
                        PROFILE = self.dlg.RoutingProfiles_8.currentText().lower()
                        timestr = time.strftime("%Y%m%d_%H%M%S")
                        ApiReqList = []
                        featuresList = []
                        failedReqs = []
                        api_dic = {}
                        failed_dic = {}
                        mode = []

                        if self.dlg.checkBox_13.isChecked():
                            mode.append('Bicycle')

                        if self.dlg.checkBox_14.isChecked():
                            mode.append('Car')

                        if self.dlg.checkBox_12.isChecked():
                            mode.append('Train')

                        if self.dlg.checkBox_11.isChecked():
                            mode.append('BusOrTram')

                        for i in range(0, len(d['features'])):
                            if d['features'][i]['properties']['mode'] in mode:
                                FROM = str(d['features'][i]['geometry']['coordinates'][0][0]) + "," + str(
                                    d['features'][i]['geometry']['coordinates'][0][1])
                                TO = str(d['features'][i]['geometry']['coordinates'][1][0]) + "," + str(
                                    d['features'][i]['geometry']['coordinates'][1][1])
                                api = "https://routing.anyways.eu/api/route?loc=" + FROM + "&loc=" + TO + "&profile=" + PROFILE
                                ApiReqList.append(api)
                                if api in api_dic.keys():
                                    api_dic[api].append(i)

                                else:
                                    api_dic.update({api: [i]})
                            else:
                                pass

                        # 1st round of reuqests
                        @backoff.on_exception(backoff.expo, aiohttp.ClientError,
                                              max_time=60)  # This is the retry function!!! Instead of "max_tries=3" one can use: "max_time=60"
                        async def get(url, session):
                            try:
                                for i in api_dic[url]:
                                    async with session.get(url=url) as response:
                                        obj = await response.json()
                                        for n in range(len(obj['features'])):
                                            obj['features'][n]['properties'] = {}
                                            obj['features'][n]['properties']['Profile'] = PROFILE
                                            obj['features'][n]['properties']['O_D'] = "%s-%s" % (
                                            d['features'][i]['properties']['from_location'],
                                            d['features'][i]['properties']['to_location'])
                                            obj['features'][n]['properties']['From_location'] = \
                                            d['features'][i]['properties']['from_location']
                                            obj['features'][n]['properties']['To_location'] = \
                                            d['features'][i]['properties']['to_location']
                                            obj['features'][n]['properties']['Movement'] = \
                                            d['features'][i]['properties']['mode']
                                            obj['features'][n]['properties']['Count'] = d['features'][i]['properties'][
                                                'count']
                                        for feats in obj['features']:
                                            featuresList.append(feats)

                            except Exception as e:
                                if url in failed_dic.keys():
                                    failed_dic[url].append(i)

                                else:
                                    failed_dic.update({url: [i]})

                        async def main(urls):
                            connector = aiohttp.TCPConnector()
                            session = aiohttp.ClientSession(connector=connector)

                            ret = await asyncio.gather(*[get(url, session) for url in urls])

                            await session.close()

                        urls = ApiReqList
                        amount = len(urls)
                        asyncio.run(main(urls))

                        # 2nd round of reuqests (if there're failed requests in the 1st round)
                        if len(failedReqs) > 0:

                            @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_tries=3)
                            async def get(url, session):
                                try:
                                    for i in failed_dic[url]:
                                        async with session.get(url=url) as response:
                                            obj = await response.json()
                                            for n in range(len(obj['features'])):
                                                obj['features'][n]['properties'] = {}
                                                obj['features'][n]['properties']['Profile'] = PROFILE
                                                obj['features'][n]['properties']['O_D'] = "%s-%s" % (
                                                d['features'][i]['properties']['from_location'],
                                                d['features'][i]['properties']['to_location'])
                                                obj['features'][n]['properties']['From_location'] = \
                                                d['features'][i]['properties']['from_location']
                                                obj['features'][n]['properties']['To_location'] = \
                                                d['features'][i]['properties']['to_location']
                                                obj['features'][n]['properties']['Movement'] = \
                                                d['features'][i]['properties']['mode']
                                                obj['features'][n]['properties']['Count'] = \
                                                d['features'][i]['properties']['count']
                                            for feats in obj['features']:
                                                featuresList.append(feats)

                                except Exception as e:
                                    failedReqs.append(url)

                            async def main(urls):
                                connector = aiohttp.TCPConnector()
                                session = aiohttp.ClientSession(connector=connector)

                                ret = await asyncio.gather(*[get(url, session) for url in urls])

                                await session.close()

                            urls = failed_dic.keys()
                            asyncio.run(main(urls))

                        else:
                            pass

                        QgsMessageLog.logMessage('\n'.join(map(str, failedReqs)), 'ImPact Toolbox', level=Qgis.Info)

                        # write FOD movements in a JSON file
                        Fname = DataSource + "_Tij_" + timestr
                        fileroute = path + "/" + Fname
                        f = open(fileroute + ".json", "w+")
                        json.dump(d, f)
                        f.close()

                        # write routings in a JSON file
                        JsonMerged['features'] = featuresList
                        Fname2 = DataSource + "_Routings_" + timestr
                        fileroute2 = path + "/" + Fname2
                        f2 = open(fileroute2 + ".json", "w+")
                        json.dump(JsonMerged, f2)
                        f2.close()

                        if self.dlg.checkBox_5.isChecked():
                            # Importing Movements JSON file
                            layer = QgsVectorLayer(fileroute + ".json", Fname, "ogr")
                            QgsProject.instance().addMapLayer(layer, True)

                            lyr = iface.activeLayer()
                            symbols = lyr.renderer().symbols(QgsRenderContext())
                            sym = symbols[0]
                            sym.setColor(QColor(255, 255, 255))
                            sym.setWidth(float(0.05))
                            lyr.triggerRepaint()
                        else:
                            pass
                        # Importing Routings JSON file
                        layer2 = QgsVectorLayer(fileroute2 + ".json", Fname2, "ogr")
                        QgsProject.instance().addMapLayer(layer2, True)

                        lyr = iface.activeLayer()
                        symbols = lyr.renderer().symbols(QgsRenderContext())
                        sym = symbols[0]
                        c = self.dlg.mColorButton_8.color()
                        sym.setColor(QColor(c))
                        sym.setWidth(float(self.dlg.lineEdit_23.text()))
                        lyr.triggerRepaint()

                elif self.dlg.tabWidget_3.currentIndex() == 1:
                    From_layer = self.dlg.mMapLayerComboBox_8.currentLayer()
                    if From_layer.crs() == 4326:
                        features = From_layer.getFeatures()
                    else:
                        crsSrc = QgsCoordinateReferenceSystem(From_layer.crs())
                        crsDest = QgsCoordinateReferenceSystem(4326)
                        xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                        features = []
                        for f in From_layer.getFeatures():
                            g = f.geometry()
                            g.transform(xform)
                            f.setGeometry(g)
                            features.append(f)

                    for feature in features:
                        vertices = feature.geometry().asMultiPolygon()

                    for v in vertices:
                        p = str(v)
                        l = [p.split(')')[0] for p in p.split('(') if ')' in p]

                    ll2 = []
                    for i in range(0, len(l)):
                        ll2.append([float(x) for x in l[i].split()])

                    To_layer = self.dlg.mMapLayerComboBox_9.currentLayer()
                    if To_layer.crs() == 4326:
                        features = To_layer.getFeatures()
                    else:
                        crsSrc = QgsCoordinateReferenceSystem(To_layer.crs())
                        crsDest = QgsCoordinateReferenceSystem(4326)
                        xform = QgsCoordinateTransform(crsSrc, crsDest, QgsProject.instance())

                        features = []
                        for f in To_layer.getFeatures():
                            g = f.geometry()
                            g.transform(xform)
                            f.setGeometry(g)
                            features.append(f)

                    for feature in features:
                        vertices = feature.geometry().asMultiPolygon()

                    for v in vertices:
                        p = str(v)
                        l = [p.split(')')[0] for p in p.split('(') if ')' in p]

                    ll = []
                    for i in range(0, len(l)):
                        ll.append([float(x) for x in l[i].split()])

                    DataSource = self.dlg.DataSource_2.currentText()

                    if DataSource.lower() == 'fod':
                        x = {"fromArea": {
                            "type": "FeatureCollection",
                            "features": [
                                {
                                    "type": "Feature",
                                    "properties": {},
                                    "geometry": {
                                        "type": "Polygon",
                                        "coordinates": [
                                            [
                                                0
                                            ]
                                        ]
                                    }
                                }
                            ]
                        },
                            "toArea": {
                                "type": "FeatureCollection",
                                "features": [
                                    {
                                        "type": "Feature",
                                        "properties": {},
                                        "geometry": {
                                            "type": "Polygon",
                                            "coordinates": [
                                                [
                                                    0
                                                ]
                                            ]
                                        }
                                    }
                                ]
                            }
                        }

                        x['fromArea']['features'][0]['geometry']['coordinates'][0] = ll2
                        x['toArea']['features'][0]['geometry']['coordinates'][0] = ll

                        data = json.dumps(x)

                        head = {'Content-type': 'application/json-patch+json', 'Accept': 'application/geo+json'}
                        response = requests.post('https://staging.anyways.eu/api/data/od/movement/area', data=data,
                                                 headers=head)

                        d = response.json()
                        if len(d['features']) == 0:
                            return self.iface.messageBar().pushMessage(u'ImPact_toolbox Error',
                                                                       u"There seem to be no Companies in the selected To-Area. Please verify at: <a href='https://staging.anyways.eu/mobility-data-explorer'>https://staging.anyways.eu/mobility-data-explorer</a>",
                                                                       level=Qgis.Critical, duration=0)
                            # QgsMessageLog.logMessage("There seem to be no Companies in the selected To-Area. Please verify at: https://staging.anyways.eu/mobility-data-explorer", 'ImPact Toolbox', level=Qgis.Info)

                        path = self.dlg.lineEdit_17.text()
                        JsonMerged = {'type': 'FeatureCollection'}
                        PROFILE = self.dlg.RoutingProfiles_6.currentText().lower()
                        timestr = time.strftime("%Y%m%d_%H%M%S")
                        INSTANCE = str.strip(self.dlg.lineEdit_19.text())
                        ApiReqList = []
                        featuresList = []
                        failedReqs = []
                        api_dic = {}
                        failed_dic = {}
                        mode = []

                        if self.dlg.checkBox_7.isChecked():
                            mode.append('Bicycle')

                        if self.dlg.checkBox_8.isChecked():
                            mode.append('Car')

                        if self.dlg.checkBox_9.isChecked():
                            mode.append('Train')

                        if self.dlg.checkBox_10.isChecked():
                            mode.append('BusOrTram')

                        for i in range(0, len(d['features'])):
                            if d['features'][i]['properties']['mode'] in mode:
                                FROM = str(d['features'][i]['geometry']['coordinates'][0][1]) + "," + str(
                                    d['features'][i]['geometry']['coordinates'][0][0])
                                TO = str(d['features'][i]['geometry']['coordinates'][1][1]) + "," + str(
                                    d['features'][i]['geometry']['coordinates'][1][0])
                                api = "https://api.anyways.eu/publish/opa/" + INSTANCE + "/routing?profile=" + PROFILE + "&loc=" + FROM + "&loc=" + TO
                                ApiReqList.append(api)
                                if api in api_dic.keys():
                                    api_dic[api].append(i)

                                else:
                                    api_dic.update({api: [i]})
                            else:
                                pass

                        # 1st round of reuqests
                        @backoff.on_exception(backoff.expo, aiohttp.ClientError,
                                              max_time=60)  # This is the retry function!!! Instead of "max_tries=3" one can use: "max_time=60"
                        async def get(url, session):
                            try:
                                for i in api_dic[url]:
                                    async with session.get(url=url) as response:
                                        obj = await response.json()
                                        for n in range(len(obj['features'])):
                                            obj['features'][n]['properties'] = {}
                                            obj['features'][n]['properties']['Profile'] = PROFILE
                                            obj['features'][n]['properties']['Instance'] = INSTANCE
                                            obj['features'][n]['properties']['O_D'] = "%s-%s" % (
                                            d['features'][i]['properties']['from_location'],
                                            d['features'][i]['properties']['to_location'])
                                            obj['features'][n]['properties']['From_location'] = \
                                            d['features'][i]['properties']['from_location']
                                            obj['features'][n]['properties']['To_location'] = \
                                            d['features'][i]['properties']['to_location']
                                            obj['features'][n]['properties']['Movement'] = \
                                            d['features'][i]['properties']['mode']
                                            obj['features'][n]['properties']['Count'] = d['features'][i]['properties'][
                                                'count']
                                        for feats in obj['features']:
                                            featuresList.append(feats)

                            except Exception as e:
                                if url in failed_dic.keys():
                                    failed_dic[url].append(i)

                                else:
                                    failed_dic.update({url: [i]})

                        async def main(urls):
                            connector = aiohttp.TCPConnector()
                            session = aiohttp.ClientSession(connector=connector)

                            ret = await asyncio.gather(*[get(url, session) for url in urls])

                            await session.close()

                        urls = ApiReqList
                        amount = len(urls)
                        asyncio.run(main(urls))

                        # 2nd round of reuqests (if there're failed requests in the 1st round)
                        if len(failedReqs) > 0:

                            @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_tries=3)
                            async def get(url, session):
                                try:
                                    for i in failed_dic[url]:
                                        async with session.get(url=url) as response:
                                            obj = await response.json()
                                            for n in range(len(obj['features'])):
                                                obj['features'][n]['properties'] = {}
                                                obj['features'][n]['properties']['Profile'] = PROFILE
                                                obj['features'][n]['properties']['Instance'] = INSTANCE
                                                obj['features'][n]['properties']['O_D'] = "%s-%s" % (
                                                d['features'][i]['properties']['from_location'],
                                                d['features'][i]['properties']['to_location'])
                                                obj['features'][n]['properties']['From_location'] = \
                                                d['features'][i]['properties']['from_location']
                                                obj['features'][n]['properties']['To_location'] = \
                                                d['features'][i]['properties']['to_location']
                                                obj['features'][n]['properties']['Movement'] = \
                                                d['features'][i]['properties']['mode']
                                                obj['features'][n]['properties']['Count'] = \
                                                d['features'][i]['properties']['count']
                                            for feats in obj['features']:
                                                featuresList.append(feats)

                                except Exception as e:
                                    failedReqs.append(url)

                            async def main(urls):
                                connector = aiohttp.TCPConnector()
                                session = aiohttp.ClientSession(connector=connector)

                                ret = await asyncio.gather(*[get(url, session) for url in urls])

                                await session.close()

                            urls = failed_dic.keys()
                            asyncio.run(main(urls))

                        else:
                            pass

                        QgsMessageLog.logMessage('\n'.join(map(str, failedReqs)), 'ImPact Toolbox', level=Qgis.Info)

                        # write FOD movements in a JSON file
                        Fname = DataSource + "_Tij_" + timestr
                        fileroute = path + "/" + Fname
                        f = open(fileroute + ".json", "w+")
                        json.dump(d, f)
                        f.close()

                        # write routings in a JSON file
                        JsonMerged['features'] = featuresList
                        Fname2 = DataSource + "_ShortCutRoutings_" + timestr
                        fileroute2 = path + "/" + Fname2
                        f2 = open(fileroute2 + ".json", "w+")
                        json.dump(JsonMerged, f2)
                        f2.close()

                        if self.dlg.checkBox_6.isChecked():
                            # Importing FOD Movements JSON file
                            layer = QgsVectorLayer(fileroute + ".json", Fname, "ogr")
                            QgsProject.instance().addMapLayer(layer, True)

                            lyr = iface.activeLayer()
                            symbols = lyr.renderer().symbols(QgsRenderContext())
                            sym = symbols[0]
                            sym.setColor(QColor(255, 255, 255))
                            sym.setWidth(float(0.05))
                            lyr.triggerRepaint()
                        else:
                            pass
                        # Importing Routings JSON file
                        layer2 = QgsVectorLayer(fileroute2 + ".json", Fname2, "ogr")
                        QgsProject.instance().addMapLayer(layer2, True)

                        lyr = iface.activeLayer()
                        symbols = lyr.renderer().symbols(QgsRenderContext())
                        sym = symbols[0]
                        c = self.dlg.mColorButton_6.color()
                        sym.setColor(QColor(c))
                        sym.setWidth(float(self.dlg.lineEdit_18.text()))
                        lyr.triggerRepaint()

            elif self.dlg.toolBox.currentIndex() == 3:
                if self.dlg.tabWidget_4.currentIndex() == 0:
                    xlfile = self.dlg.lineEdit_27.text()
                    path = self.dlg.lineEdit_26.text()
                    SheetName = self.dlg.lineEdit_28.text()
                    # check if the string "sheetname" is empty, read the first (default) sheet of the excel file
                    if not SheetName.strip():
                        SheetName = 0
                    df = pd.read_excel(xlfile, sheet_name=SheetName)
                    dicFinal = {"type": "FeatureCollection", "features": []}

                    col_list = list(df.columns)
                    col_list2 = ['From', 'From-lat', 'From-long', 'To', 'To-lat', 'To-long']

                    def set_approach(a, b):
                        return list(set(a) - set(b))

                    mode_list = set_approach(col_list, col_list2)

                    for m in mode_list:
                        for index, row in df.iterrows():
                            if row[m] > 0:
                                f = []
                                f.append(row['From-long'])
                                f.append(row['From-lat'])
                                t = []
                                t.append(row['To-long'])
                                t.append(row['To-lat'])

                                geometry = {"type": "LineString", "coordinates": []}
                                geometry["coordinates"].append(f)
                                geometry["coordinates"].append(t)
                                properties = {}
                                properties["from_location"] = row['From']
                                properties["to_location"] = row['To']
                                properties["mode"] = m
                                properties["count"] = row[m]

                                dic3 = {"type": "Feature", "bbox": [], "geometry": geometry, "properties": properties}
                                dic3["bbox"].append(row['To-long'])
                                dic3["bbox"].append(row['To-lat'])
                                dic3["bbox"].append(row['From-long'])
                                dic3["bbox"].append(row['From-lat'])

                                dicFinal["features"].append(dic3)

                        # QgsMessageLog.logMessage(xlfile, 'ImPact Toolbox', level=Qgis.Info)

                    # path=('C:/APIRequest/Movement file creation/')
                    Fname = "Tij_" + xlfile.split('/')[-1][:-5]
                    fileroute = path + "/" + Fname
                    f = open(fileroute + ".json", "w+")
                    json.dump(dicFinal, f)
                    f.close()

                    if self.dlg.checkBox_15.isChecked():
                        # Importing Movements JSON file
                        layer = QgsVectorLayer(fileroute + ".json", Fname, "ogr")
                        QgsProject.instance().addMapLayer(layer, True)

                        lyr = iface.activeLayer()
                        symbols = lyr.renderer().symbols(QgsRenderContext())
                        sym = symbols[0]
                        c = self.dlg.mColorButton_9.color()
                        sym.setColor(QColor(c))
                        sym.setWidth(float(self.dlg.lineEdit_25.text()))
                        lyr.triggerRepaint()
                    else:
                        pass

                elif self.dlg.tabWidget_4.currentIndex() == 1:
                    Tij = self.dlg.lineEdit_29.text()
                    d = json.loads(open(Tij).read())
                    path = self.dlg.lineEdit_15.text()
                    JsonMerged = {'type': 'FeatureCollection'}
                    PROFILE = self.dlg.RoutingProfiles_5.currentText().lower()
                    m = str.strip(self.dlg.lineEdit_16.text())
                    m2 = m.replace(', ', ',').replace(' ,', ',')
                    mode = m2.lower().split(',')
                    timestr = time.strftime("%Y%m%d_%H%M%S")
                    ApiReqList = []
                    featuresList = []
                    failedReqs = []
                    api_dic = {}
                    failed_dic = {}

                    for i in range(0, len(d['features'])):
                        if d['features'][i]['properties']['mode'].lower() in mode:
                            FROM = str(d['features'][i]['geometry']['coordinates'][0][0]) + "," + str(
                                d['features'][i]['geometry']['coordinates'][0][1])
                            TO = str(d['features'][i]['geometry']['coordinates'][1][0]) + "," + str(
                                d['features'][i]['geometry']['coordinates'][1][1])
                            api = "https://routing.anyways.eu/api/route?loc=" + FROM + "&loc=" + TO + "&profile=" + PROFILE
                            ApiReqList.append(api)
                            if api in api_dic.keys():
                                api_dic[api].append(i)

                            else:
                                api_dic.update({api: [i]})
                        else:
                            pass

                    # 1st round of reuqests
                    @backoff.on_exception(backoff.expo, aiohttp.ClientError,
                                          max_time=60)  # This is the retry function!!! Instead of "max_tries=3" one can use: "max_time=60"
                    async def get(url, session):
                        try:
                            for i in api_dic[url]:
                                async with session.get(url=url) as response:
                                    obj = await response.json()
                                    for n in range(len(obj['features'])):
                                        obj['features'][n]['properties'] = {}
                                        obj['features'][n]['properties']['Profile'] = PROFILE
                                        obj['features'][n]['properties']['O_D'] = "%s-%s" % (
                                        d['features'][i]['properties']['from_location'],
                                        d['features'][i]['properties']['to_location'])
                                        obj['features'][n]['properties']['From_location'] = \
                                        d['features'][i]['properties']['from_location']
                                        obj['features'][n]['properties']['To_location'] = \
                                        d['features'][i]['properties']['to_location']
                                        obj['features'][n]['properties']['Movement'] = d['features'][i]['properties'][
                                            'mode']
                                        obj['features'][n]['properties']['Count'] = d['features'][i]['properties'][
                                            'count']
                                    for feats in obj['features']:
                                        featuresList.append(feats)

                        except Exception as e:
                            if url in failed_dic.keys():
                                failed_dic[url].append(i)

                            else:
                                failed_dic.update({url: [i]})

                    async def main(urls):
                        connector = aiohttp.TCPConnector()
                        session = aiohttp.ClientSession(connector=connector)

                        ret = await asyncio.gather(*[get(url, session) for url in urls])

                        await session.close()

                    urls = ApiReqList
                    amount = len(urls)
                    asyncio.run(main(urls))

                    # 2nd round of reuqests (if there're failed requests in the 1st round)
                    if len(failedReqs) > 0:

                        @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_tries=3)
                        async def get(url, session):
                            try:
                                for i in failed_dic[url]:
                                    async with session.get(url=url) as response:
                                        obj = await response.json()
                                        for n in range(len(obj['features'])):
                                            obj['features'][n]['properties'] = {}
                                            obj['features'][n]['properties']['Profile'] = PROFILE
                                            obj['features'][n]['properties']['O_D'] = "%s-%s" % (
                                            d['features'][i]['properties']['from_location'],
                                            d['features'][i]['properties']['to_location'])
                                            obj['features'][n]['properties']['From_location'] = \
                                            d['features'][i]['properties']['from_location']
                                            obj['features'][n]['properties']['To_location'] = \
                                            d['features'][i]['properties']['to_location']
                                            obj['features'][n]['properties']['Movement'] = \
                                            d['features'][i]['properties']['mode']
                                            obj['features'][n]['properties']['Count'] = d['features'][i]['properties'][
                                                'count']
                                        for feats in obj['features']:
                                            featuresList.append(feats)

                            except Exception as e:
                                failedReqs.append(url)

                        async def main(urls):
                            connector = aiohttp.TCPConnector()
                            session = aiohttp.ClientSession(connector=connector)

                            ret = await asyncio.gather(*[get(url, session) for url in urls])

                            await session.close()

                        urls = failed_dic.keys()
                        asyncio.run(main(urls))

                    else:
                        pass

                    # QgsMessageLog.logMessage('\n'.join(map(str, failedReqs)), 'ImPact Toolbox', level=Qgis.Info)

                    # write routings in a JSON file
                    JsonMerged['features'] = featuresList
                    Fname2 = "Routings_" + Tij.split('/')[-1][:-5] + timestr
                    fileroute2 = path + "/" + Fname2
                    f2 = open(fileroute2 + ".json", "w+")
                    json.dump(JsonMerged, f2)
                    f2.close()

                    # Importing Routings JSON file
                    layer2 = QgsVectorLayer(fileroute2 + ".json", Fname2, "ogr")
                    QgsProject.instance().addMapLayer(layer2, True)

                    lyr = iface.activeLayer()
                    symbols = lyr.renderer().symbols(QgsRenderContext())
                    sym = symbols[0]
                    c = self.dlg.mColorButton_5.color()
                    sym.setColor(QColor(c))
                    sym.setWidth(float(self.dlg.lineEdit_14.text()))
                    lyr.triggerRepaint()

                elif self.dlg.tabWidget_4.currentIndex() == 2:
                    Tij2 = self.dlg.lineEdit_31.text()
                    d = json.loads(open(Tij2).read())
                    path = self.dlg.lineEdit_20.text()
                    JsonMerged = {'type': 'FeatureCollection'}
                    PROFILE = self.dlg.RoutingProfiles_7.currentText().lower()
                    INSTANCE = str.strip(self.dlg.lineEdit_22.text())
                    m = str.strip(self.dlg.lineEdit_30.text())
                    m2 = m.replace(', ', ',').replace(' ,', ',')
                    mode = m2.lower().split(',')
                    timestr = time.strftime("%Y%m%d_%H%M%S")
                    ApiReqList = []
                    featuresList = []
                    failedReqs = []
                    api_dic = {}
                    failed_dic = {}

                    for i in range(0, len(d['features'])):
                        if d['features'][i]['properties']['mode'].lower() in mode:
                            FROM = str(d['features'][i]['geometry']['coordinates'][0][1]) + "," + str(
                                d['features'][i]['geometry']['coordinates'][0][0])
                            TO = str(d['features'][i]['geometry']['coordinates'][1][1]) + "," + str(
                                d['features'][i]['geometry']['coordinates'][1][0])
                            api = "https://api.anyways.eu/publish/opa/" + INSTANCE + "/routing?profile=" + PROFILE + "&loc=" + FROM + "&loc=" + TO
                            ApiReqList.append(api)
                            if api in api_dic.keys():
                                api_dic[api].append(i)

                            else:
                                api_dic.update({api: [i]})
                        else:
                            pass

                    # 1st round of reuqests
                    @backoff.on_exception(backoff.expo, aiohttp.ClientError,
                                          max_time=60)  # This is the retry function!!! Instead of "max_tries=3" one can use: "max_time=60"
                    async def get(url, session):
                        try:
                            for i in api_dic[url]:
                                async with session.get(url=url) as response:
                                    obj = await response.json()
                                    for n in range(len(obj['features'])):
                                        obj['features'][n]['properties'] = {}
                                        obj['features'][n]['properties']['Profile'] = PROFILE
                                        obj['features'][n]['properties']['Instance'] = INSTANCE
                                        obj['features'][n]['properties']['O_D'] = "%s-%s" % (
                                        d['features'][i]['properties']['from_location'],
                                        d['features'][i]['properties']['to_location'])
                                        obj['features'][n]['properties']['From_location'] = \
                                        d['features'][i]['properties']['from_location']
                                        obj['features'][n]['properties']['To_location'] = \
                                        d['features'][i]['properties']['to_location']
                                        obj['features'][n]['properties']['Movement'] = d['features'][i]['properties'][
                                            'mode']
                                        obj['features'][n]['properties']['Count'] = d['features'][i]['properties'][
                                            'count']
                                    for feats in obj['features']:
                                        featuresList.append(feats)

                        except Exception as e:
                            if url in failed_dic.keys():
                                failed_dic[url].append(i)

                            else:
                                failed_dic.update({url: [i]})

                    async def main(urls):
                        connector = aiohttp.TCPConnector()
                        session = aiohttp.ClientSession(connector=connector)

                        ret = await asyncio.gather(*[get(url, session) for url in urls])

                        await session.close()

                    urls = ApiReqList
                    amount = len(urls)
                    asyncio.run(main(urls))

                    # 2nd round of reuqests (if there're failed requests in the 1st round)
                    if len(failedReqs) > 0:

                        @backoff.on_exception(backoff.expo, aiohttp.ClientError, max_tries=3)
                        async def get(url, session):
                            try:
                                for i in failed_dic[url]:
                                    async with session.get(url=url) as response:
                                        obj = await response.json()
                                        for n in range(len(obj['features'])):
                                            obj['features'][n]['properties'] = {}
                                            obj['features'][n]['properties']['Profile'] = PROFILE
                                            obj['features'][n]['properties']['Instance'] = INSTANCE
                                            obj['features'][n]['properties']['O_D'] = "%s-%s" % (
                                            d['features'][i]['properties']['from_location'],
                                            d['features'][i]['properties']['to_location'])
                                            obj['features'][n]['properties']['From_location'] = \
                                            d['features'][i]['properties']['from_location']
                                            obj['features'][n]['properties']['To_location'] = \
                                            d['features'][i]['properties']['to_location']
                                            obj['features'][n]['properties']['Movement'] = \
                                            d['features'][i]['properties']['mode']
                                            obj['features'][n]['properties']['Count'] = d['features'][i]['properties'][
                                                'count']
                                        for feats in obj['features']:
                                            featuresList.append(feats)

                            except Exception as e:
                                failedReqs.append(url)

                        async def main(urls):
                            connector = aiohttp.TCPConnector()
                            session = aiohttp.ClientSession(connector=connector)

                            ret = await asyncio.gather(*[get(url, session) for url in urls])

                            await session.close()

                        urls = failed_dic.keys()
                        asyncio.run(main(urls))

                    else:
                        pass

                    # QgsMessageLog.logMessage('\n'.join(map(str, failedReqs)), 'ImPact Toolbox', level=Qgis.Info)

                    # write routings in a JSON file
                    JsonMerged['features'] = featuresList
                    Fname2 = "ShortCutRoutings_" + Tij2.split('/')[-1][:-5] + timestr
                    fileroute2 = path + "/" + Fname2
                    f2 = open(fileroute2 + ".json", "w+")
                    json.dump(JsonMerged, f2)
                    f2.close()

                    # Importing Routings JSON file
                    layer2 = QgsVectorLayer(fileroute2 + ".json", Fname2, "ogr")
                    QgsProject.instance().addMapLayer(layer2, True)

                    lyr = iface.activeLayer()
                    symbols = lyr.renderer().symbols(QgsRenderContext())
                    sym = symbols[0]
                    c = self.dlg.mColorButton_7.color()
                    sym.setColor(QColor(c))
                    sym.setWidth(float(self.dlg.lineEdit_21.text()))
                    lyr.triggerRepaint()
